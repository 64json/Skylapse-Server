<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Skylapse Hays</title>
    <style>
        html,
        body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            background-color: black;
            padding: 8px;
        }

        * {
            box-sizing: border-box;
        }

        #container {
            align-self: center;
        }

        #form {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            padding: 8px;
        }

        #form select,
        #form input,
        #form button {
            -webkit-appearance: none;
            padding: 8px;
            margin: 8px;
            background-color: white;
            color: black;
            border: 1px solid #DDDDDD;
            border-radius: 0;
        }

        #player {
            display: none;
            max-width: 100vw;
            max-height: 25vh;
            padding: 8px;
        }

        #container.play #form {
            display: none;
        }

        #container.play #player {
            display: block;
        }

        #logger {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            padding: 8px;
        }

        .line {
            font-size: 12px !important;
        }

        .log {
            color: green;
        }

        .warn {
            color: yellow;
        }

        .error {
            color: red;
        }
    </style>
</head>
<body>
<div id="container">
    <form id="form">
        <select id="device_id"></select>
        <input type="text" id="page_id" placeholder="Page ID" />
        <input type="text" id="access_token" placeholder="Access Token" />
        <button type="submit">Start</button>
    </form>
    <video id="player" controls autoplay></video>
</div>
<div id="logger"></div>
<script src="whammy.js"></script>
<script src="jquery-3.2.1.min.js"></script>
<script>
  /**
   * References
   * -
   * https://developers.google.com/web/fundamentals/media/capturing-images/
   * https://github.com/samdutton/simpl
   * https://github.com/muaz-khan/Ffmpeg.js
   * https://github.com/antimatter15/whammy
   */

  const second = 1000;
  const minute = 60 * second;
  const hour = 60 * minute;
  const day = 24 * hour;

  const container = document.getElementById('container');
  const form = document.getElementById('form');
  const device_id = document.getElementById('device_id');
  const page_id = document.getElementById('page_id');
  const access_token = document.getElementById('access_token');
  const player = document.getElementById('player');
  const logger = document.getElementById('logger');

  navigator.mediaDevices.enumerateDevices()
    .then(deviceInfos => {
      for (let i = 0; i !== deviceInfos.length; ++i) {
        const deviceInfo = deviceInfos[i];
        const option = document.createElement('option');
        option.value = deviceInfo.deviceId;
        if (deviceInfo.kind === 'videoinput') {
          option.text = deviceInfo.label || 'camera ' + (device_id.length + 1);
          device_id.appendChild(option);
        }
      }
    })
    .catch(console.error);

  form.addEventListener('submit', e => {
    e.preventDefault();
    container.classList.add('play');
    const deviceId = device_id.value;
    const pageId = page_id.value;
    const accessToken = access_token.value;

    player.addEventListener('loadedmetadata', () => {
      cronJob(2 * second, 10, 5, 'test');
      //cronJob(10 * second, 360, 30, 'hourly');
      //cronJob(1 * minute, 360, 30, 'every_6hrs');
      //cronJob(4 * minute, 360, 30, 'daily');
    }, false);

    navigator.mediaDevices.getUserMedia({
      video: {
        deviceId: { exact: deviceId }
      }
    })
      .then(stream => {
        player.srcObject = stream;
      })
      .catch(console.error);

    function cronJob(INTERVAL, FRAMES, FPS, TAG) {
      const canvas = document.createElement('canvas');
      canvas.width = player.videoWidth;
      canvas.height = player.videoHeight;

      const encoder = new Whammy.Video(FPS);
      let frames = 0;

      const timer = setInterval(() => {
        const context = canvas.getContext('2d');
        context.drawImage(player, 0, 0, canvas.width, canvas.height);
        encoder.add(canvas);

        console.log(`Picture taken. (${TAG} - frame #${frames})`);

        if (++frames >= FRAMES) {
          clearInterval(timer);
          cronJob(INTERVAL, FRAMES, FPS, TAG);
          encoder.compile(false, webmBlob => {
            convertStreams(webmBlob, mp4Blob => {
              const description = [
                `${FPS}fps time-lapse over ${readable(INTERVAL * FRAMES)}.`,
                `${FRAMES} pictures taken every ${readable(INTERVAL)}.`,
                '',
                `#skylapse_hays_${TAG}`,
              ].join('\n');
              postVideo(mp4Blob, description);
            });
          });
        }
      }, INTERVAL);
    }

    function processInWebWorker() {
      const workerPath = 'https://archive.org/download/ffmpeg_asm/ffmpeg_asm.js';
      const blob = URL.createObjectURL(new Blob(['importScripts("' + workerPath + '");var now = Date.now;function print(text) {postMessage({"type" : "stdout","data" : text});};onmessage = function(event) {var message = event.data;if (message.type === "command") {var Module = {print: print,printErr: print,files: message.files || [],arguments: message.arguments || [],TOTAL_MEMORY: message.TOTAL_MEMORY || false};postMessage({"type" : "start","data" : Module.arguments.join(" ")});postMessage({"type" : "stdout","data" : "Received command: " +Module.arguments.join(" ") +((Module.TOTAL_MEMORY) ? ".  Processing with " + Module.TOTAL_MEMORY + " bits." : "")});var time = now();var result = ffmpeg_run(Module);var totalTime = now() - time;postMessage({"type" : "stdout","data" : "Finished processing (took " + totalTime + "ms)"});postMessage({"type" : "done","data" : result,"time" : totalTime});}};postMessage({"type" : "ready"});'], {
        type: 'application/javascript'
      }));
      const worker = new Worker(blob);
      URL.revokeObjectURL(blob);
      return worker;
    }

    function convertStreams(webmBlob, callback) {
      const worker = processInWebWorker();
      worker.onmessage = event => {
        const message = event.data;
        switch (message.type) {
          case 'ready':
            console.log('ffmpeg-asm.js file has been loaded.');
            break;
          case 'stdout':
            console.log(message.data);
            break;
          case 'start':
            console.log('ffmpeg-asm.js file received ffmpeg command.');
            break;
          case 'done':
            const result = message.data[0];
            const mp4Blob = new File([result.data], 'test.mp4', { type: 'video/mp4' });
            if (callback) callback(mp4Blob);
            break;
        }
      };
      const fileReader = new FileReader();
      fileReader.onload = function () {
        worker.postMessage({
          type: 'command',
          arguments: '-i video.webm -c:v mpeg4 -b:v 6400k -strict experimental output.mp4'.split(' '),
          files: [
            {
              data: new Uint8Array(this.result),
              name: 'video.webm'
            }
          ]
        });
      };
      fileReader.readAsArrayBuffer(webmBlob);
    }

    function postVideo(source, description) {
      console.log(description);

      if (!accessToken) {
        window.open(URL.createObjectURL(source));
        return;
      }

      const data = new FormData();
      data.append('access_token', accessToken);
      data.append('source', source);
      data.append('description', description);
      data.append('no_story', true);
      $.ajax({
        url: `https://graph-video.facebook.com/v2.11/${pageId}/videos`,
        type: 'POST',
        data,
        processData: false,
        contentType: false,
        cache: false,
        success: (data, status, xhr) => {
          console.log(xhr.responseText);
        },
        error: (xhr, status, data) => {
          console.error(xhr.responseText);
        },
      });
    }

    function readable(v) {
      const d = v / day | 0;
      const h = v % day / hour | 0;
      const m = v % hour / minute | 0;
      const s = v % minute / second | 0;
      const ms = v % second;
      return [
        d && (d + ' day(s)'),
        h && (h + ' hour(s)'),
        m && (m + ' minute(s)'),
        s && (s + ' second(s)'),
        ms && (ms + ' millisecond(s)'),
      ].filter(v => v).join(' ');
    }

  });

  const originalConsole = window.console;

  function intercept(method, args) {
    const message = Array.prototype.slice.apply(args).join(' ');
    const line = document.createElement('span');
    line.classList.add('line');
    line.classList.add(method);
    line.appendChild(document.createTextNode(message));
    logger.appendChild(line);
    if (logger.children.length > 1000) {
      logger.removeChild(logger.children[0]);
    }
    line.scrollIntoView();
    originalConsole[method].apply(originalConsole, args);
  }

  window.console = {
    log: function () {
      intercept('log', arguments);
    },
    warn: function () {
      intercept('warn', arguments);
    },
    error: function () {
      intercept('error', arguments);
    }
  };
</script>
</body>
</html>